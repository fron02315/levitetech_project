{"ast":null,"code":"import React, { useRef, useEffect, useState, useLayoutEffect, forwardRef } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction attachRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else if (typeof ref === 'object') {\n    ref.current = node;\n  }\n}\n\nfunction combineRef() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return function functionalRef(node) {\n    args.filter(function (arg) {\n      return arg != null;\n    }).forEach(function (ref) {\n      return attachRef(ref, node);\n    });\n  };\n}\n\nvar position = function position(placement, overlay, trigger, offsetParent, arrowSize) {\n  if (arrowSize === void 0) {\n    arrowSize = 0;\n  }\n\n  var overlayBcr = overlay.getBoundingClientRect();\n  var triggerBcr = trigger.getBoundingClientRect();\n  var offsetBcr = offsetParent.getBoundingClientRect();\n  var style = {\n    top: 0,\n    left: 0\n  };\n  var offsetTop = triggerBcr.top - offsetBcr.top;\n  var offsetLeft = triggerBcr.left - offsetBcr.left;\n\n  switch (placement) {\n    case 'top':\n      {\n        style.top = offsetTop - overlayBcr.height - arrowSize;\n        style.left = offsetLeft + (triggerBcr.width - overlayBcr.width) / 2;\n        break;\n      }\n\n    case 'bottom':\n      {\n        style.top = offsetTop + triggerBcr.height + arrowSize;\n        style.left = offsetLeft + (triggerBcr.width - overlayBcr.width) / 2;\n        break;\n      }\n\n    case 'left':\n      {\n        style.top = offsetTop + (triggerBcr.height - overlayBcr.height) / 2;\n        style.left = offsetLeft - overlayBcr.width - arrowSize;\n        break;\n      }\n\n    case 'right':\n      {\n        style.top = offsetTop + (triggerBcr.height - overlayBcr.height) / 2;\n        style.left = offsetLeft + triggerBcr.width + arrowSize;\n        break;\n      }\n\n    case 'center':\n      {\n        style.top = offsetTop + (triggerBcr.height - overlayBcr.height) / 2;\n        style.left = offsetLeft + (triggerBcr.width - overlayBcr.width) / 2;\n        break;\n      }\n  }\n\n  var offset = {\n    top: style.top,\n    left: style.left,\n    bottom: style.top,\n    right: style.left\n  };\n  var popupRect = {\n    top: offset.top + offsetBcr.top,\n    left: offset.left + offsetBcr.left,\n    bottom: offset.top + offsetBcr.top,\n    right: offset.left + offsetBcr.left\n  };\n  return {\n    offset: offset,\n    rect: popupRect\n  };\n};\n\nvar mutationObserverOption = {\n  subtree: true,\n  childList: true,\n  attributes: true,\n  characterData: true\n};\n\nfunction createObserver(node, onMeasure) {\n  if (window.ResizeObserver) {\n    var ro = new ResizeObserver(function () {\n      return onMeasure();\n    });\n    ro.observe(node);\n    return ro;\n  } else {\n    var handleMutate = function handleMutate() {\n      var _node$getBoundingClie = node.getBoundingClientRect(),\n          width = _node$getBoundingClie.width,\n          height = _node$getBoundingClie.height;\n\n      if (cachedSize.width !== width || cachedSize.height !== height) {\n        cachedSize.width = width;\n        cachedSize.height = height;\n        onMeasure();\n      }\n    };\n\n    var cachedSize = {\n      width: 0,\n      height: 0\n    };\n    var mob = new MutationObserver(handleMutate);\n    mob.observe(node, mutationObserverOption);\n    return mob;\n  }\n}\n\nvar DomObserver = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var children = _ref.children,\n      _ref$onMeasure = _ref.onMeasure,\n      onMeasure = _ref$onMeasure === void 0 ? function () {} : _ref$onMeasure;\n  var innerRef = useRef(null);\n  useEffect(function () {\n    var node = innerRef.current;\n    var observer = null;\n\n    if (node) {\n      observer = createObserver(node, onMeasure);\n    }\n\n    return function () {\n      if (observer) {\n        observer.disconnect();\n      }\n    };\n  }, []);\n  return /*#__PURE__*/React.cloneElement(children, {\n    ref: combineRef(innerRef, ref, children.ref)\n  });\n});\n\nfunction Overlay(_ref) {\n  var children = _ref.children,\n      onClose = _ref.onClose,\n      getTrigger = _ref.getTrigger,\n      placement = _ref.placement,\n      innerRef = _ref.innerRef,\n      ctr = _ref.container,\n      _ref$arrowProps = _ref.arrowProps,\n      arrowProps = _ref$arrowProps === void 0 ? {\n    size: 0\n  } : _ref$arrowProps,\n      adjustOverlayRef = _ref.adjustOverlayRef;\n  var overlayRef = useRef();\n\n  var _useState = useState(ctr),\n      container = _useState[0],\n      setContainer = _useState[1];\n\n  var _useState2 = useState({\n    offsetTop: 0,\n    offsetLeft: 0\n  }),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  useLayoutEffect(function () {\n    if (container !== ctr) {\n      setContainer(ctr);\n    }\n  }, [ctr]);\n  useLayoutEffect(function () {\n    adjustPosition();\n  }, []);\n  useLayoutEffect(function () {\n    adjustPosition();\n  }, [container, placement, arrowProps]);\n\n  var getStyle = function getStyle() {\n    var offsetTop = state.offsetTop,\n        offsetLeft = state.offsetLeft;\n    var transforms = \"translate3d(\" + offsetLeft + \"px, \" + offsetTop + \"px, 0)\";\n    return {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      transform: transforms,\n      WebkitTransform: transforms,\n      MozTransform: transforms,\n      msTransform: transforms\n    };\n  };\n\n  var adjustPosition = function adjustPosition() {\n    var triggerNode = getTrigger();\n    var overlayNode = overlayRef.current;\n\n    if (!triggerNode || !overlayNode || !container) {\n      return;\n    }\n\n    var expected = position(placement, overlayNode, triggerNode, container, arrowProps.size);\n    var _expected$offset = expected.offset,\n        top = _expected$offset.top,\n        left = _expected$offset.left;\n    var offsetTop = state.offsetTop,\n        offsetLeft = state.offsetLeft;\n\n    if (top !== offsetTop || left !== offsetLeft) {\n      setState({\n        offsetTop: top,\n        offsetLeft: left\n      });\n    }\n  };\n\n  useEffect(function () {\n    adjustOverlayRef.current = adjustPosition;\n  });\n  if (!container || !children) return null;\n  return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(DomObserver, {\n    ref: combineRef(overlayRef, innerRef),\n    onMeasure: adjustPosition\n  }, /*#__PURE__*/React.cloneElement(children, {\n    style: _extends({}, children.props.style, getStyle()),\n    onClose: onClose\n  })), container);\n}\n\nvar isBrowser = typeof window !== 'undefined';\nvar isPointerEventSupported = isBrowser ? !!window.PointerEvent : false;\nvar isTouchEventSupported = isBrowser ? !!window.TouchEvent : false;\nvar defaultContainer = isBrowser ? document.body : null;\n\nvar safeCall = function safeCall(fn) {\n  if (typeof fn === 'function') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    fn.apply(void 0, args);\n  }\n};\n\nfunction DocumentClick(_ref) {\n  var condition = _ref.condition,\n      callback = _ref.callback;\n\n  var handleClick = function handleClick(e) {\n    if (condition(e)) {\n      callback();\n    }\n  };\n\n  useEffect(function () {\n    document.addEventListener('click', handleClick);\n    return function () {\n      return document.removeEventListener('click', handleClick);\n    };\n  }, [condition, callback]);\n  return null;\n}\n\nfunction OverlayTrigger(props) {\n  var triggerRef = useRef();\n  var overlayRef = useRef();\n  var adjustOverlayRef = useRef(function () {});\n\n  var _useState = useState(false),\n      visible = _useState[0],\n      setVisible = _useState[1];\n\n  function getChildProps() {\n    return props.children.props;\n  }\n\n  function handleMouseEnter(e) {\n    safeCall(getChildProps().onMouseEnter, e);\n\n    if (!isPointerEventSupported && !isTouchEventSupported) {\n      open();\n    }\n  }\n\n  function handleMouseLeave(e) {\n    safeCall(getChildProps().onMouseLeave, e);\n\n    if (!isPointerEventSupported && !isTouchEventSupported) {\n      close();\n    }\n  }\n\n  function handlePointerEnter(e) {\n    safeCall(getChildProps().onPointerEnter, e);\n\n    if (e.pointerType === 'mouse') {\n      open();\n    }\n  }\n\n  function handlePointerLeave(e) {\n    safeCall(getChildProps().onPointerLeave, e);\n\n    if (e.pointerType === 'mouse') {\n      close();\n    }\n  }\n\n  function handleClick(e) {\n    safeCall(getChildProps().onClick, e);\n\n    if (visible) {\n      close();\n    } else {\n      open();\n    }\n  }\n\n  function isClickOutside(e) {\n    var target = e.target;\n    var overlay = overlayRef.current;\n    var trigger = triggerRef.current; // outside of the trigger or overlay\n\n    return trigger && !trigger.contains(target) && overlay && !overlay.contains(target);\n  }\n\n  function handleFocus(e) {\n    safeCall(getChildProps().onFocus, e);\n    open();\n  }\n\n  function handleBlur(e) {\n    safeCall(getChildProps().onBlur, e);\n    close();\n  }\n\n  function getTriggerProps() {\n    var triggers = props.triggers;\n    var passedProps = {};\n\n    if (triggers.indexOf('hover') !== -1) {\n      passedProps.onMouseEnter = handleMouseEnter;\n      passedProps.onMouseLeave = handleMouseLeave;\n      passedProps.onPointerEnter = handlePointerEnter;\n      passedProps.onPointerLeave = handlePointerLeave;\n    }\n\n    if (triggers.indexOf('focus') !== -1) {\n      passedProps.onFocus = handleFocus;\n      passedProps.onBlur = handleBlur;\n    }\n\n    if (triggers.indexOf('click') !== -1) {\n      passedProps.onClick = handleClick;\n    }\n\n    return passedProps;\n  }\n\n  function open() {\n    setVisible(true);\n  }\n\n  function close() {\n    setVisible(false);\n  }\n\n  function getTrigger() {\n    return triggerRef.current;\n  }\n\n  function scheduleUpdate() {\n    var adjustOverlay = adjustOverlayRef.current;\n    adjustOverlay();\n  }\n\n  var children = props.children,\n      _props$container = props.container,\n      container = _props$container === void 0 ? defaultContainer : _props$container,\n      overlay = props.overlay,\n      arrowProps = props.arrowProps,\n      placement = props.placement,\n      innerRef = props.innerRef;\n  var child = React.Children.only(children);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DomObserver, {\n    ref: combineRef(triggerRef, innerRef),\n    onMeasure: scheduleUpdate\n  }, child != null && child !== false && /*#__PURE__*/React.cloneElement(child, getTriggerProps())), /*#__PURE__*/React.createElement(DocumentClick, {\n    condition: isClickOutside,\n    callback: close\n  }), visible && /*#__PURE__*/React.createElement(Overlay, {\n    onClose: close,\n    arrowProps: arrowProps,\n    container: container,\n    placement: placement,\n    getTrigger: getTrigger,\n    innerRef: overlayRef,\n    adjustOverlayRef: adjustOverlayRef\n  }, overlay));\n}\n\nvar OverlayTrigger$1 = /*#__PURE__*/forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(OverlayTrigger, Object.assign({}, props, {\n    innerRef: ref\n  }));\n});\nexport { OverlayTrigger$1 as default };","map":null,"metadata":{},"sourceType":"module"}